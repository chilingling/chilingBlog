---
layout: post
title: LeetCode 213 打家劫舍 Ⅱ
author: 炽凌
date: 2019-04-11
categories: LeetCode
tags: LeetCode
comments: true
finished: true
---

> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈，**这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

> 给定一个代表每个房屋存放金额的非负整数数组，计算你**在不触动警报装置的情况下，**能够偷窃到的最高金额。

示例一

```
输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

示例二

```
输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

题目分析：

既然所有的房屋都围成一个圈，这就意味着第一间和最后一间房间不能一起偷，所以我们的选择变成了从`0-n-1`间和`1-n`间，取决于这两个队列哪一个偷的比较多，此时，我们的问题已经退化成为了打家劫舍一中的问题了

编码实现

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    if (nums.length === 0) {
        return 0
    }
    if (nums.length === 1) {
        return nums[0]
    }
    if (nums.length === 2) {
        return Math.max(nums[0], nums[1])
    }
    let rob01 = [nums[0]]
    rob01[1] = Math.max(nums[1], nums[0])
    let rob02 = [nums[1]]
    rob02[1] = Math.max(nums[2], nums[1])
    for (let i = 2; i < nums.length; ++i) {
        if (i < nums.length - 1) {
            rob01[i] = Math.max(rob01[i-2] + nums[i], rob01[i-1])    
        }
        if (i > 2) {
            rob02[i-1] = Math.max(rob02[i-3] + nums[i], rob02[i-2])     
        }
    }
    return Math.max(rob01[rob01.length-1], rob02[rob02.length-1])
};
```

